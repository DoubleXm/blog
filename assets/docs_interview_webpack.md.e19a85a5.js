import{_ as l,o as e,c as i,Q as a}from"./chunks/framework.45bffcbf.js";const o=JSON.parse('{"title":"","description":"","frontmatter":{"layout":"doc"},"headers":[],"relativePath":"docs/interview/webpack.md","lastUpdated":1687189963000}'),c={name:"docs/interview/webpack.md"},d=[a('<h2 id="loader-和-plugin-有什么不同" tabindex="-1">Loader 和 Plugin 有什么不同 <a class="header-anchor" href="#loader-和-plugin-有什么不同" aria-label="Permalink to &quot;Loader 和 Plugin 有什么不同&quot;">​</a></h2><p>Loader 直译为&quot;加载器&quot;。Webpack 将⼀切⽂件视为模块，但是 webpack 原⽣是只能解析 js ⽂件，如果想将其他⽂件也打包的话，就会⽤到 loader 。 所以 Loader 的作⽤是让 webpack 拥有了加载和解析⾮ JavaScript ⽂件的能⼒。</p><details class="details custom-block"><summary>常用的 loader</summary><ul><li>babel-loader 把 JS/TS 变成 JS</li><li>ts-loader 把 TS 变成 JS，并提示类型错误</li><li>markdown-loader 把 markdown 变成 html</li><li>html-loader 把 html 变成 JS 字符串</li><li>sass-loader 把 SASS/SCSS 变成 CSS</li><li>css-loader 把 CSS 变成 JS 字符串</li><li>style-loader 把 JS 字符串变成 style 标签</li><li>postcss-loader 把 CSS 变成更优化的 CSS</li><li>vue-loader 把单文件组件（SFC）变成 JS 模块</li><li>thread-loader 用于多进程打包</li><li>file-loader 解决图片引入问题，将图片 copy 到指定目录(默认 dist)</li><li>url-loader 将小于 limit 选项配置大小的图片转换为 base64 编码，大于 limit 选项配置大小的图片还是采用 file-loader</li></ul></details><p>Plugin 直译为&quot;插件&quot;。Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。在 Webpack 运⾏的⽣命周期中会⼴播出许多事 件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p><details class="details custom-block"><summary>常用的 plugin</summary><ul><li>html-webpack-plugin 用于创建 HTML 页面并自动引入 JS 和 CSS</li><li>clean-webpack-plugin 用于清理之前打包的残余文件</li><li>mini-css-extract-plugin 用于将 JS 中的 CSS 抽离成单独的 CSS 文件</li><li>SplitChunksPlugin 用于代码分包（Code Split）</li><li>DllPlugin + DllReferencePlugin 用于避免大依赖被频繁重新打包，大幅降低打包时间</li><li>eslint-webpack-plugin 用于检查代码中的错误</li><li>DefinePlugin 用于在 webpack config 里添加全局变量</li><li>copy-webpack-plugin 用于拷贝静态文件到 dist</li></ul></details><h2 id="bundle-chunk-module-是什么" tabindex="-1">bundle，chunk，module 是什么 <a class="header-anchor" href="#bundle-chunk-module-是什么" aria-label="Permalink to &quot;bundle，chunk，module 是什么&quot;">​</a></h2><ul><li>bundle：是由 webpack 打包出来的⽂件；</li><li>chunk：代码块，⼀个 chunk 由多个模块组合⽽成，⽤于代码的合并 和分割；</li><li>module：是开发中的单个模块，在 webpack 的世界，⼀切皆模块，⼀ 个模块对应⼀个⽂件，webpack 会从配置的 entry 中递归开始找出所 有依赖的模块。</li></ul><h2 id="webpack-的构建流程" tabindex="-1">webpack 的构建流程 <a class="header-anchor" href="#webpack-的构建流程" aria-label="Permalink to &quot;webpack 的构建流程&quot;">​</a></h2><ul><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li><li>确定入口：根据配置中的 entry 找出所有的入口文件；</li><li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li><li>完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ul><h2 id="webpack-层面如何性能优化" tabindex="-1">Webpack 层面如何性能优化？ <a class="header-anchor" href="#webpack-层面如何性能优化" aria-label="Permalink to &quot;Webpack 层面如何性能优化？&quot;">​</a></h2><p><strong>优化构建速度</strong></p><ul><li>构建费时分析 <code>speed-measure-webpack-plugin</code></li><li>构建进度查看：<code>progress-bar-webpack-plugin</code></li><li><code>resolve</code> 配置优化 <ul><li><code>alias</code> 别名，用来简化模块的引用</li><li><code>extensions</code> 当用户引入的文件不带后缀名，手动配置会覆盖默认配置。[&#39;.ts&#39;, &#39;...&#39;]，...表示采用默认配置</li><li><code>modules</code> 告诉 <code>webpack</code> 优先查找 src 目录中的文件，modules: [resolve(&#39;src&#39;), &#39;node_modules&#39;]</li></ul></li><li><code>externals</code> 剥离不需要改动的一些依赖(从输出的 bundle 中排除依赖)</li><li><code>loader</code> 中使用 include 解析符合条件的模块、exclude 排除(不解析)符合条件的模块，优先级高于 include</li><li><code>noParse</code> 不解析依赖的第三方类库等</li><li><code>IgnorePlugin</code> 防止在 import 或 require 调用时，生成 contextRegExp 指定资源不符合 requestRegExp 正则匹配的资源</li><li><code>thread-loader</code> 开启多进程打包，happypack webpack5 已经弃用了</li><li><code>babel-loader</code> 启用缓存，缓存结果，大幅提升重新构建 js 文件的速度</li><li><code>cache-loader</code> 缓存其他 loader 的构建结果</li><li><code>hard-source-webpack-plugin</code> 为模块提供中间缓存，重复构建时间大约可以减少 80%，但是在 webpack5 中已经内置了模块缓存，不需要再使用此插件</li><li><code>cache</code> 通过配置 cache 来缓存生成的 webpack 模块和 chunk，来改善构建速度</li></ul><p><strong>优化构建结果</strong></p><ul><li>webpack-bundle-analyzer 对构建结果分析</li><li>optimize-css-assets-webpack-plugin 压缩 css 文件</li><li>terser-webpack-plugin 压缩 js 文件，在生成环境下打包默认会开启 js 压缩，但是当我们手动配置 optimization 选项之后，就不再默认对 js 进行压缩，需要我们手动去配置</li><li>purgecss-webpack-plugin 单独提取 css 文件并清除用不到的 css</li><li>Tree-shaking 剔除没有使用的代码，webpack 默认支持，需要在 .bablerc 里面设置 model：false，即可在生产环境下默认开启</li><li>Scope Hoisting Scope Hoisting 即作用域提升，原理是将多个模块放在同一个作用域下，并重命名防止命名冲突，通过这种方式可以减少函数声明和内存开销，只支持 es6 语法，生产环境默认开启</li></ul><p><strong>优化运行时体验</strong></p><ul><li>入口点分割：配置多个打包入口，多页打包</li><li>splitChunks 分包配置，webpack 将根据以下条件自动拆分 chunks： <ul><li>新的 chunk 可以被共享，或者模块来自于 node_modules 文件夹</li><li>新的 chunk 体积大于 20kb（在进行 min+gz 之前的体积）</li><li>当按需加载 chunks 时，并行请求的最大数量小于或等于 30</li><li>当加载初始化页面时，并发请求的最大数量小于或等于 30</li></ul></li><li>代码懒加载：当有需要用户交互后才加载的资源时，可以当用户操作后，引入资源 <ul><li>webpackprefetch (预获取)：浏览器空闲的时候进行资源的拉取</li><li>webpackpreload (预加载)：提前加载后面会用到的关键资源</li></ul></li></ul>',16)];const r=l(c,[["render",function(l,a,o,c,r,s){return e(),i("div",null,d)}]]);export{o as __pageData,r as default};
