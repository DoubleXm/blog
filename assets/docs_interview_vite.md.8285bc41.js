import{_ as e,o,c as s,Q as l}from"./chunks/framework.45bffcbf.js";const a=JSON.parse('{"title":"","description":"","frontmatter":{"layout":"doc"},"headers":[],"relativePath":"docs/interview/vite.md","lastUpdated":1687189963000}'),n={name:"docs/interview/vite.md"},c=[l('<h2 id="vite-为什么这么快-快在了哪里" tabindex="-1">vite 为什么这么快，快在了哪里 <a class="header-anchor" href="#vite-为什么这么快-快在了哪里" aria-label="Permalink to &quot;vite 为什么这么快，快在了哪里&quot;">​</a></h2><ul><li>项目启动快</li></ul><p>Vite 在打包的时候，将模块分成两个区域 <strong>依赖</strong> 和 <strong>源码</strong> ：</p><p><strong>依赖</strong> ：一般是那种在开发中不会改变的 <code>JavaScript</code>，比如组件库，或者一些较大的依赖（可能有上百个模块的库），这一部分使用 <code>esbuild</code> 来进行 预构建依赖 , <code>esbuild</code> 使用的是 <code>Go</code> 进行编写，比 <code>JavaScript</code> 编写的打包器预构建依赖快 10-100 倍</p><p><strong>源码</strong> ：一般是哪种好修改几率比较大的文件，例如 <code>JSX、CSS、vue</code> 这些需要转换且时常会被修改编辑的文件。同时，这些文件并不是一股脑全部加载，而是可以按需加载（例如路由懒加载）。 <code>Vite</code> 会将文件转换后，以 <code>es module</code> 的方式直接交给浏览器，因为现在的浏览器大多数都直接支持 <code>es module</code> ，这使性能提高了很多</p><p>Vite 是直接把转换后的 es module 的 JavaScript 代码，扔给 支持 es module 的浏览器 ，让浏览器自己去加载依赖，也就是把压力丢给了 浏览器 ，从而达到了项目启动速度快的效果。</p><p><img src="/blog/interview/browser/vite1.png" alt="vite1"></p><ul><li>项目更新快</li></ul><p>项目启动时，将模块分成 <strong>依赖</strong> 和 <strong>源码</strong> ，当你更新代码时， <strong>依赖</strong> 就不需要重新加载，只需要精准地找到是哪个 <strong>源码</strong> 的文件更新了，更新相对应的文件就行了。这样做使得更新速度非常快。</p><p><code>Vite</code> 同时利用 <code>HTTP</code> 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>源码模块的请求会根据 <code>304 Not Modified</code> 进行协商缓存。</p><p>而依赖模块请求则会通过 <code>Cache-Control: max-age=31536000</code>, <code>immutable</code> 进行强缓存，因此一旦被缓存它们将不需要再次请求。</p></div><ul><li>生产环境快</li></ul><p>为了在生产环境中获得最佳的加载性能，使用了 <code>rollup</code> 将代码进行 <code>tree-shaking</code>、懒加载和 <code>chunk</code> 分割、CSS 处理，这些优化操作，目前 <code>esbuild</code> 还不怎么完善</p><h2 id="vite-与-webpack-对比" tabindex="-1">vite 与 webpack 对比 <a class="header-anchor" href="#vite-与-webpack-对比" aria-label="Permalink to &quot;vite 与 webpack 对比&quot;">​</a></h2><p>由于 <code>Vite</code> 主打的是开发环境的极致体验，生产环境集成 <code>Rollup</code>，这里的对比主要是 <code>Webpack-dev-server</code> 与 <code>Vite-dev-server</code> 的对比：</p><ul><li><code>Webpack</code> 配置丰富使用极为灵活但上手成本高，<code>Vite</code> 开箱即用配置高度集成</li><li><code>Webpack</code> 启动服务需打包构建，速度慢，<code>Vite</code> 免编译可秒开</li><li><code>Webpack</code> 热更新需打包构建，速度慢，<code>Vite</code> 毫秒响应</li><li><code>Webpack</code> 成熟稳定、资源丰富、大量实践案例，<code>Vite</code> 实践较少</li><li><code>Vite</code> 使用 <code>esbuild</code> 编译，构建速度比 <code>webpack</code> 快几个数量级</li></ul><h2 id="双引擎架构实现" tabindex="-1">双引擎架构实现 <a class="header-anchor" href="#双引擎架构实现" aria-label="Permalink to &quot;双引擎架构实现&quot;">​</a></h2><p><img src="/blog/interview/browser/vite2.png" alt="vite2"></p><ul><li><p>开发阶段：<code>ESBuild</code> 依赖预构建 主要是 ESM 格式的兼容性问题和海量请求的问题</p></li><li><p>单文件编译——作为 <code>TS</code> 和 <code>JSX</code> 编译工具 <code>ESBuild</code> 代替 <code>bable</code> 的工作，对代码进行 <code>transformer</code></p></li><li><p>生产环境 <code>ESBuild</code> 代码压缩</p></li><li><p>生产环境 <code>Bundle</code> 基于 <code>Rollup</code></p><ol><li><code>CSS</code> 代码分割。如果某个异步模块中引入了一些 <code>CSS</code> 代码，<code>Vite</code> 就会自动将这些 CSS 抽取出来生成单独的文件，提高线上产物的缓存复用率。</li><li>自动预加载。<code>Vite</code> 会自动为入口 chunk 的依赖自动生成预加载标签 <code>&lt;link rel=&quot;moduelpreload&quot;&gt;</code> 会让浏览器提前下载好资源，优化页面性能，如:</li></ol><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">head</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">&lt;!-- 省略其它内容 --&gt;</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">&lt;!-- 入口 chunk --&gt;</span></span>\n<span class="line"><span style="color:#89DDFF;">  &lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">module</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">crossorigin</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">/assets/index.250e0340.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">&lt;!--  自动预加载入口 chunk 所依赖的 chunk--&gt;</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">link</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">rel</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">modulepreload</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">href</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">/assets/vendor.293dca09.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> /&gt;</span></span>\n<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">head</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ol start="3"><li>异步 <code>Chunk</code> 加载优化 如现有两个异步引入的 <code>Chunk</code>: A 和 B，而且两者有一个公共依赖 C</li></ol><p>一般情况下，<code>Rollup</code> 打包之后，会先请求 A，然后浏览器在加载 A 的过程中才决定请求和加载 C</p><p>但 <code>Vite</code> 进行优化之后，请求 A 的同时会自动预加载 C，通过优化 Rollup 产物依赖加载方式节省了不必要的网络开销。</p></li></ul><h2 id="vite-预构建主要做了些什么" tabindex="-1">vite 预构建主要做了些什么 <a class="header-anchor" href="#vite-预构建主要做了些什么" aria-label="Permalink to &quot;vite 预构建主要做了些什么&quot;">​</a></h2><p>Vite 中的依赖预构建技术主要解决了 2 个问题，即模块格式兼容问题和海量模块请求的问题。</p>',21)];const t=e(n,[["render",function(e,l,a,n,t,p){return o(),s("div",null,c)}]]);export{a as __pageData,t as default};
