## 存储引擎

表的类型就是存储引擎。最常用的就是 `InnoDB` （目前的主流）支持事务，行锁，外键。此外还有

- `myisam`: `mysql 5.6` 之前使用的存储引擎，支持全文检索
- `memory`: 缓存存储引擎，插入的数据不会被真正的存储到硬盘中，会在内存中存储，重启后数据消失
- `blackhole`: 黑洞存储引擎，任何写入的数据都不会被存储，主要用于测试或者丢弃不需要的写入数据。

```sql
show engines; -- 查看表支持的存储引擎

/**
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
9 rows in set (0.00 sec)
 */
```

```sql
-- 新建 db2 数据库基于不同存储引擎创建表
create database db2 charset=utf8;
use db2;

create table t1 (id int, name char(4)) charset=utf8 engine=blackhole;
create table t2 (id int, name char(4)) charset=utf8 engine=innodb;
create table t3 (id int, name char(4)) charset=utf8 engine=memory;
create table t4 (id int, name char(4)) charset=utf8 engine=myisam;

-- 针对四张表每个都插入一条数据
insert into t1 (1, 'a');
insert into t2 (1, 'a');
insert into t3 (1, 'a');
insert into t4 (1, 'a');

-- 执行 select 语句查询数据；
-- 结果 t2, t3, t4 都有数据
-- 重启 mysql 服务后 t3 数据也会消失
```

针对不同的存储引擎，查看 `mysql` 都创建了什么文件？

```bash
-rw-r----- 1 mysql mysql    61 Sep 26 10:54 db.opt
-rw-r----- 1 mysql mysql  8586 Sep 26 10:58 t1.frm # 只有结构文件，因为它根本就不存储数据
-rw-r----- 1 mysql mysql  8586 Sep 26 10:58 t2.frm # innodb 分别存储结构文件和数据文件
-rw-r----- 1 mysql mysql 98304 Sep 26 11:03 t2.ibd
-rw-r----- 1 mysql mysql  8586 Sep 26 10:59 t3.frm # 只有结构文件，因为不会有数据存储到磁盘
-rw-r----- 1 mysql mysql  8586 Sep 26 10:59 t4.frm # myisam 的结构文件
-rw-r----- 1 mysql mysql    17 Sep 26 11:03 t4.MYD # myisam 数据文件
-rw-r----- 1 mysql mysql  1024 Sep 26 11:06 t4.MYI # myisam 索引文件，表的索引、行数等关键数据
```

## 表的操作

### 创建表语法

```sql
create table <表名> (
  <字段1> <字段类型>[(宽度)] [约束条件],
  <字段2> <字段类型>[(宽度)] [约束条件],
  <字段3> <字段类型>[(宽度)] [约束条件1 约束条件2]
);

-- 宽度指字符的个数，也就是字符串的长度
```

**约束条件**

- `unsigned` 无符号
- `not null` 非空, 字符类型空字符串填充，数字类型 0 填充。优先级较低，卸载条件的最后。
- `zerofill` 0 填充，当指定数字宽度的时候位数不足的会以 0 进行填充

### 修改表语法

```sql
-- 修改存储引擎
alter table <表名> engine=<新的存储引擎>;

-- 修改表名
alter table <表名> rename <新表名>;

-- 增加字段 first 插入到最前面，after 字段名 某个字段的后面
alter table <表名> add <字段名> <字段类型>[(宽度)] [约束条件] [first|after <字段名>];

-- 删除字段
alter table <表名> drop <字段名>;

-- 修改字段类型
alter table <表名> modify <字段名> <字段类型>[(宽度)] [约束条件];

-- 修改表字段
alter table <表名> change <旧字段名> <新字段名><字段类型>[(宽度)] [约束条件];
```

约束条件就是，当在操作数据的时候，增加一些条件，比如创建一个表, 再去查询表的字段信息, 可以看出第三列是允许为 `null` 值的可以往里面插入空的内容, 内容如下：

```sql
create table t6 (id int, name char(4)) charset=utf8;
describe t6;

/**
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| id    | int(11) | YES  |     | NULL    |       |
| name  | char(4) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
2 rows in set (0.00 sec)
 */

insert into t6 values (null, null);
select *  from t6;

/**
+------+------+
| id   | name |
+------+------+
| NULL | NULL |
+------+------+
1 row in set (0.00 sec)
 */
```

此时就可以通过约束条件，在建表或者表内没有不允许的数据时去增加约束条件，比如表内已经存在 `null` 值你在去修改这个字段不能为 `null` 是无法修改成功的。

```sql
-- 创建 table
create table t7 (id int, name char) charset=utf8;

-- 设置 id 不能为null
alter table t7 modify id int not null;
-- 修改 name 的字段名并且设置不能为 null
alter table t7 change name Name char not null;

describe t7;
/**
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| id    | int(11) | NO   |     | NULL    |       |
| Name  | char(1) | NO   |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
2 rows in set (0.00 sec)
 */
```

### 删除和复制表语法

```sql
-- 删除表
drop table <表名>;

-- 复制表内容以及表结构
-- * 可以指定对应的字段，那么就是只复制这几个字段的内容
-- 条件成立就是符合条件的查询内容和表结构，如果条件不成立就是复制表结构
create table <新表名> select * from <旧表名> [条件];

-- 复制表结构
create table <新表名> like <旧表名>
```

具体测试**复制表内容以及表结构**如下：

::: code-group

```sql [target]
/**
movies 表内容及结构如下
+------+--------------+------+
| id   | name         | dir  |
+------+--------------+------+
|    1 | 流浪地球     | NULL |
|    2 | 满江红       | NULL |
+------+--------------+------+

+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| id    | int(11)  | YES  |     | NULL    |       |
| name  | char(4)  | YES  |     | NULL    |       |
| dir   | char(16) | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+
 */
```

```sql [source]
-- 复制 movies 表内容及结构到 t1 表。
create table t1 select * from movies;
-- 可执行的验证脚本如下：
show tables;
describe t1;
select * from t1;

-- 复制 id 为 1 内容到 t2 表
create table t2 select *  from movies where id=1;

-- 只复制 id 到 t3 表, 并只复制表结构
create table t3 select id from movies where 1=2; -- where 后的表达式永远不成立，则只会

-- 复制表结构
create table t4 like movies;
```

:::

## 数据类型

### 数值类型

#### int

**科普：1 字节等价于 8 比特，8 个二进制数存储数字最大就是 255**

| 类型        |   大小    |                                范围(有符号) |              范围(无符号) |       描述 |
| ----------- | :-------: | ------------------------------------------: | ------------------------: | ---------: |
| `tinyint`   | `1 Bytes` |                                 `-128, 127` |                  `0, 255` | 很小的整数 |
| `smallint`  | `2 Bytes` |                             `-32768, 32767` |                `0, 65535` | 较小的整数 |
| `mediumint` | `3 Bytes` |                         `-8388608, 8388607` |             `0, 16777215` | 一般的整数 |
| `int`       | `4 Bytes` |                   `-2147483648, 2147483647` |           `0, 4294967295` | 标准的整数 |
| `bigint`    | `5 Bytes` | `-9223372036854775808, 9223372036854775807` | `0, 18446744073709551615` | 一般的整数 |

以 `tinyint` 为例，数据库字段最大被插入的范围就应该是 `-128, 127` 之间的数字，如果大于这个数字就不能被插入到数据库。示例代码如下：

```sql
create table t1 (n tinyint);
-- 插入符合规范的最大数
insert into t1 values (-128), (127);
select * from t1;
/**
+------+
| n    |
+------+
| -128 |
|  127 |
+------+
2 rows in set (0.00 sec)
 */

-- 插入不符合规范的数
insert into t1 values (-129), (128);
-- ERROR 1264 (22003): Out of range value for column 'n' at row 1
```

**默认情况下创建出来的字段都是有符号的，如果需要创建无符号的字段就需要另一个约束条件 `unsigned`**

```sql
-- 给 t1 增加一个约束条件的字段
alter table t1 add m tinyint unsigned;
insert into t1 values (0, 255);

/**
可以看出插入的数据没有默认值，就会显示为 NULL, 思考如果在加上 not null 约束条件后呢？
+------+------+
| n    | m    |
+------+------+
| -128 | NULL |
|  127 | NULL |
|    1 |  255 |
+------+------+
 */

-- 创建字段 y 为无符号约束，并且不能为 null, 结果是应该为 NULL 地方全部变成 0
alter table t1 add y tinyint unsigned not null;

-- 如果不能为空的字符类型就对应的是空字符串
alter table t1 add x char not null;
```

整型的宽度实际上是显示字符的宽度，与字符串没有关系。意义实际上并不大。如果想要验证显示字符的宽度，需要用到约束条件 `zerofill` 0 填充。

```sql
create table t3 (n int(3) zerofill) charset=utf8;
insert into t3 values (1), (12), (123), (1234567);

/** 不足三位的 0 补齐, 大于三位的 0 处理。
+---------+
| n       |
+---------+
|     001 |
|     012 |
|     123 |
| 1234567 |
+---------+
 */

-- 如果不指定宽度的话，无符号的宽度会比有符号的宽度少 1， 因为有符号多存了一个负号
create table t4 (x int not null, y int zerofill unsigned not null) charset=utf8 engine=innodb;
/**
+-------+---------------------------+------+-----+---------+-------+
| Field | Type                      | Null | Key | Default | Extra |
+-------+---------------------------+------+-----+---------+-------+
| x     | int(11)                   | NO   |     | NULL    |       |
| y     | int(10) unsigned zerofill | NO   |     | NULL    |       |
+-------+---------------------------+------+-----+---------+-------+
 */
```

#### float

**注意：第一个参数表示字符长度，第二个参数表示小数长度， 比如 float(255, 30) 那么这个字段就是 255-30 整数字符数，小数字符数为 30**

**float 和 double 还会有精度问题，但是一般情况下也足够了，decimal 精度较高常用于一些金融、数据分析类数据**

| 类型      |                       大小                       |                                      范围(有符号) |                 范围(无符号) |           描述 |
| --------- | :----------------------------------------------: | ------------------------------------------------: | ---------------------------: | -------------: |
| `float`   |   `4 Bytes`指定范围 m 最大值 255, d 最大值 30    |     `-3.4E+38 ~ -1.17E-38、0和1.17E-38 ~ 3.4E+38` |   `0 和 1.17E-38 到 3.4E+38` | 单精度浮点数值 |
| `double`  |   `8 Bytes` 指定范围 m 最大值 255, d 最大值 30   | `-1.7E+308 ~ -2.23E-308、0和2.23E-308 ~ 1.7E+308` | `0 和 2.23E-308 到 1.7E+308` | 双精度浮点数值 |
| `decimal` | `decimal(m,d)` 指定范围 m 最大值 65, d 最大值 30 |                                依赖于 m 和 d 的值 |           依赖于 m 和 d 的值 |         小数值 |

```sql
-- 创建指定字段的表
create table t1 (n float(255, 30)) charset=utf8 engine=innodb;
create table t2 (n double(255, 30)) charset=utf8 engine=innodb;
create table t3 (n decimal(65,  30)) charset=utf8 engine=innodb;

-- 插入 30 位小数的值
insert into t1 values (0.111111111111111111111111111111);
/**
+----------------------------------+
| n                                |
+----------------------------------+
| 0.111111111938953400000000000000 |
+----------------------------------+ */
insert into t2 values (0.111111111111111111111111111111);
/**
+----------------------------------+
| n                                |
+----------------------------------+
| 0.111111111111111100000000000000 |
+----------------------------------+ */
insert into t3 values (0.111111111111111111111111111111);
/**
+----------------------------------+
| n                                |
+----------------------------------+
| 0.111111111111111111111111111111 |
+----------------------------------+ */
```

### 字符类型

字符类型主要分为两种 `char` 和 `varchar` 都是可以指定字符的长度。**它们之间的区别是 `char` 会在如果不足的时候会在末尾补齐空格，在取的时候删除空格。`varchar` 则不会。**

- `char` 每次存取都是固定的字符对于已经固定的内容比如 hash 值，使用 `char` 性能会比较好, 但是比较浪费资源。最大 255 字符。
- `varchar` 存多少取多少，不会浪费资源，但是性能对比 `char` 略低。 最大 65535 个字节，但要考虑到需要一个字节为 `NULL` 标识，`varchar` 的每一个数据都要有个头用来记录长度的标识， 当数据长度小于 255 的时候，头占一个字节，当数据长度大于 255 小于 65535 的时候，头占两个字节。但是你还要考虑因为是字节转换成字符的时候也有差异，比如 `gpk` 一个字符是两个字节，`utf8` 一个字符是三个字节。

**总结：大多数情况下还是用的还是 `varchar` 宽度尽可能不要超过 255 因为超过 255 后还要多加一个字节存储字符的长度**

```sql
create table t4 (x char(10), y varchar(10)) charset=utf8 engine=innodb;
insert into t4 values ('  x  ', '  y  ');

-- char_length 用来获取字符的长度
select char_length(x), char_length(y) from t4;
/** 从结果可以看出 char 把结尾的空格给去掉了。varchar 则是原文输出
+----------------+----------------+
| char_length(x) | char_length(y) |
+----------------+----------------+
|              3 |              5 |
+----------------+----------------+ */

-- 测试 utf8 下 varchar 的最大范围 65535 / 3 - 1 = 21844
create table t6 (s varchar(21845)) charset=utf8 engine=innodb;
-- ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs

create table t6 (s varchar(21844)) charset=utf8 engine=innodb;

-- 并且创建 varchar 类型的时候，需要注意一行的数据最大也是 65535，如果这一行有多个字段，varchar 会更小
create table t7 (id int, name varchar(21842)) charset=utf8 engine=innodb;
```

### 时间日期类型

- `year` 年份,格式为 YYYY,例如 2023
- `date` 日期,格式为'YYYY-MM-DD',例如 '2023-02-28'
- `time` 时间,格式为'HH:MM:SS',例如 '15:30:20'
- `datetime` 日期+时间,格式为'YYYY-MM-DD HH:MM:SS',例如 '2023-02-28 15:30:20', 是'1000-01-01 00:00:00' 到 '9999-12-31 23:59:59'。8 个字节
- `timestamp` 时间戳,格式同 DATETIME,但存储的是从 UTC 时间 1970-01-01 00:00:00 到现在的秒数，是 1970 年至 2038 年之间的日期时间。4 个字节

```sql
create table t8 (
  id int,
  name varchar(16),
  born year,
  birth date,
  active time,
  reg_time datetime
) charset=utf8 engine=innodb;

-- 使用 now 函数获取当前的日期, 当数据存储的时候 mysql 会自行处理。
insert into t8 values (1, 'xx', now(), now(), now(), now());
-- 如果想要插入自定义的时间和日期，传入符合格式的字符串即可。
insert into t8 values (2, 'yy', '2000', '2000-02-22', '18:00:00', '2000-02-22 18:00:00');

/**
+------+------+------+------------+----------+---------------------+
| id   | name | born | birth      | active   | reg_time            |
+------+------+------+------------+----------+---------------------+
|    1 | xx   | 2023 | 2023-09-26 | 17:36:08 | 2023-09-26 17:36:08 |
|    2 | yy   | 2000 | 2000-02-22 | 18:00:00 | 2000-02-22 18:00:00 |
+------+------+------+------------+----------+---------------------+ */
```

### 枚举和集合

`enum` 枚举和 `set` 都是用来限定用户可以用来创建什么样的值，`enum` 为单选、`set` 为多选。

```sql
create table t9 (
  id int,
  name varchar(16),
  gender enum('male', 'female', 'other'),
  hobbies set('sing', 'jump', 'rap')
);

insert into t9 values
  (1, 'xx', 'male', 'sing'),
  (2, 'cc', 'other', 'sing,jump,rap');
/**
+------+------+--------+---------------+
| id   | name | gender | hobbies       |
+------+------+--------+---------------+
|    1 | xx   | male   | sing          |
|    2 | cc   | other  | sing,jump,rap |
+------+------+--------+---------------+ */
```

## 条件约束

上面其实已经有关于约束条件使用的案例了,

```sql
-- 优先级排序如下：
-- unsigned = zerofill > not null = default

[unsigned] [zerofill] [not null] [default]
-- `unsigned` 无符号
-- `zerofill` 0 填充

-- `not null` 不能为空
-- `default` 设置默认值
```

目前来看你可能会疑问为什么 `not null` 一定要在 `unsigned`、`zerofill` 的后面。

```sql
create table t10 (id int zerofill unsigned not null);
describe t10;
/** 可以看出 zerofill unsigned 是针对 type 的约束，not null 是针对值的约束
+-------+---------------------------+------+-----+---------+-------+
| Field | Type                      | Null | Key | Default | Extra |
+-------+---------------------------+------+-----+---------+-------+
| id    | int(10) unsigned zerofill | NO   |     | NULL    |       |
+-------+---------------------------+------+-----+---------+-------+ */
```

```sql
create table t11 (id int, name varchar(16), gender enum('male', 'female') not null default 'male');

-- 插入数据时可以指定插入字段的内容，如果没有插入的值设置了默认值，则使用这个默认值
insert into t11 (id, name) values (1, 'xx');
insert into t11 values (2, 'ff', 'female');
/**
+------+------+--------+
| id   | name | gender |
+------+------+--------+
|    1 | xx   | male   |
|    2 | cc   | female |
+------+------+--------+ */
```
