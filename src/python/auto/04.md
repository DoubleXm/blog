---
outline: deep
---

`pytest` 是一个三方的单元测试框架，框架可以轻松编写小型、可读的测试，并且可以扩展以支持应用程序和库的复杂功能测试。

```bash :no-line-numbers
pip install pytest
# uv
uv add pytest

# 验证版本 pytest 8.4.2
uv run pytest --version 
```

## 快速开始

在 `pytest` 中不再追求固定范式，可以是函数、也可以是类。但是希望你的被测试方法函数名以 `test_` 开头。当测试用例过多时，我仍然建议你使用 `class` 去组织测试用例。

```py
def test_math_add():
    assert 1 + 2 == 3

def test_math_sub():
    assert 1 - 2 == -1

class TestString:
    def test_string_upper(self):
        assert "hello".upper() == "HELLO"

    def test_string_lower(self):
        assert "HELLO".lower() == "hello"
```

执行 `uv run pytest test_demo.py` 上述四个用例会被全部执行。

## 命令行

`pytest` 的测试发现规则是 `test_*.py`、 `*_test.py`。在文件中也会寻找包含 `test` 的类或者方法。

```bash :no-line-numbers
# 执行单个文件
pytest test_demo.py
# 执行目录
pytest testing/

# -k 指定测试用例
# 不包含 math 的测试都要被执行。
# 可以被使用的关键字 and not or
pytest -k "not math" testing/

# -v 运行更详细的测试用例。控制台输出更多的信息
pytest -v testing/

# -s 允许输出 print 信息
pytest -s testing/

# -m
# 运行所有 @pytest.mark.slow 标记的测试用例
# 也可以是这样 "slow(phase=1)"
pytest -m show

# 也可以通过 :: 指定方法或者类的运行
# 1. 指定类下的指定方法
pytest test_demo.py::TestString::test_string_upper
# 2. 指定类
pytest test_demo.py::TestString
# 3. 为方法传递参数
pytest test_demo.py::test_math_add[1, 2]
```

**需要注意的是，当指定方法的时候它就只是一个文件中的方法(`pytest test_demo.py::test_math_add`)，不然你应该做的是指定类下面的方法 `pytest test_demo.py::TestString::test_string_upper`**


## TestFixture

这应该是 `pytest` 出圈的主要功能了，提供的复用能力比较与 `unittest` 强大了很多。强的头皮发麻....

### 快速开始

从示例中看，**被 `@pytest-fixture` 装饰器所包裹的方法都会被执行并且被测试函数所使用。此外他们自身还可以被其他 `fixture` 所使用。**

可能有点绕，举个例子，以测试加法运算为例。可是把预期和参数都作为 `fixture` 传入。

```py
@pytest.fixture
def add_params():
    return 1, 2

@pytest.fixture
def add_result():
    return 3

# pytest.fixture 会执行被装饰的方法并且拿到返回值
def test_add(add_params, add_result):
    assert sum(add_params) == add_result
```

再或者甚至可以将运算的过程放在 `add_result` 中。以达到 `fixture` 之间引用的目的。当然我只是想为你演示他们之间执行的过程，没有别的意思。

```py
@pytest.fixture
def add_params():
    return 1, 2

# 接收 add_params 这个 fixture
@pytest.fixture
def get_add_result_is_successed(add_params):
    return sum(add_params) == 3

def test_add(get_add_result_is_successed):
    assert get_add_result_is_successed
```

实际上这都是 `pytest` 为你做的事情，如果是自己执行，则需要以下方案

```py
def add_params():
    return 1, 2

def get_add_result_is_successed(add_params):
    return sum(add_params) == 3

def test_add(get_add_result_is_successed):
    assert get_add_result_is_successed

if __name__ == "__main__":
    add_params = add_params() # 执行 add_params
    get_add_result_is_successed(add_params) # 执行 get_add_result_is_successed
    test_add(get_add_result_is_successed) # 执行 test_add
```

### Fixture 中的数据复用

还有一个比较重要的点 `fixture` 和用例之间的数据是能够被复用。最好不要有通过用例去改变他返回值的想法。

```py
@pytest.fixture
def add_params():
    return [1, 2]

def test_add_params(add_params):
    add_params.append(3)
    assert add_params == [1, 2, 3]

def test_add(add_params):
    assert add_params == [1, 2]
```

在多个 `fixture` 内部数据的数据可以被复用，并且会被最终返回。**用例中则会拿到最终数据，这一切的前提是你使用了更改那个数据的 `fixture`。这一切还是主要归功于 `@pytest.fixture` 的自动执行函数的特性。**

```py
@pytest.fixture
def list_data():
    return [1, 2]

@pytest.fixture
def append_list_data(list_data):
    list_data.append(3)
    return list_data

# Error
def test_01_add_params(list_data):
    assert list_data == [1, 2, 3]
# Success
def test_02_add_params(append_list_data, list_data):
    assert list_data == [1, 2, 3]
```

### 自动使用 autouse

当为 `@pytest.fixture` 增加此参数后，无论是否使用了该 `fixture` 他都会被执行。

```py
@pytest.fixture
def mock_test_data():
    return 'test data'

@pytest.fixture
def mock_test_container():
    return []

# 无论有没有被使用，都会被执行
# 其背部已经更改了 mock_test_container 的返回值
@pytest.fixture(autouse=True)
def mock_autouse(mock_test_data, mock_test_container):
    return mock_test_container.append(mock_test_data)

# Successed
def test_01(mock_test_container):
    assert mock_test_container == ['test data']
```

### Fixture 的作用域

这是一个比较重要的功能，就像在 `unittest` 中的 `setUp` 一样。理论上来说作用域越大，复用性越高。但是也要结合实际情况。

同样的，你需要向 `@pytest.fixture` 传递参数，名为 `scope`。 取值包含 `function`、`class`、`module`、`package`、`session`。默认值为 `function`。

- `function`：默认范围，在测试结束时被销毁。
- `class`：在拆卸类中的最后一个测试时，被销毁。
- `module`：在拆卸模块中的最后一个测试时，被销毁。
- `package`：在拆卸包中的最后一个测试时，包括其中的子包和子目录。被销毁。
- `session`：在整个测试会话结束时，被销毁。

实际上这些作用域的大小，是根据你项目中文件的组织结构来定的。

#### function

`function` 作用域，**每个函数都会执行一次**

```py
@pytest.fixture
def mock_test_data():
    print('function scope staring....')

def test_01(mock_test_data):
    print('function test ... 🚀')

def test_02(mock_test_data):
    print('function test ... 🚀')

# function scope staring....
# function test ... 🚀
# function scope staring....
# function test ... 🚀
```

#### class

`class` 作用域，**在类中只会调用一次**

```py
@pytest.fixture(scope='class')
def mock_test_dict():
    print('class scope starting...')

class TestDict:
    def test_dict_01(self, mock_test_dict):
        print('class test ... 🚀')

    def test_dict_02(self, mock_test_dict):
        print('class test ... 🚀')

# class scope starting...
# class test ... 🚀
# class test ... 🚀
```

#### module

`module` 作用域，**在模块(一个文件)中会调用一次，无论有多少个测试用例或者类和方法**

```py
@pytest.fixture(scope='module')
def mock_test_dict():
    print('module scope starting...')

def test_dict_01(mock_test_dict):
    print('module test ... 🚀')

def test_dict_02(mock_test_dict):
    print('module test ... 🚀')

# module scope starting...
# module test ... 🚀
# module test ... 🚀
```

#### package 

`package` 作用域，**在包(一个目录，可以嵌套)中会调用一次，无论有多少个测试用例或者类和方法。实际上你不存在 `__init__.py` 也会被当做包。**

```py
@pytest.fixture(scope='package')
def mock_test_dict():
    print('package scope starting...')

# package scope starting...
```

#### session 

`session` 作用域，**在整个测试会话结束时，被销毁。** 从作用的范围来看在项目中 `package` 和 `session` 的使用没有太大区别。

```py
@pytest.fixture(scope='session')
def mock_test_dict():
    print('session scope starting...')

# session scope starting...
```

#### 执行顺序与逻辑抽离

执行顺序上来看，`session -> package -> module -> class -> function`。

```py
@pytest.fixture(scope='session')
def session_fixture():
    print('session scope starting...')

@pytest.fixture(scope='package')
def package_fixture():
    print('package scope starting...')

@pytest.fixture(scope='module')
def module_fixture():
    print('module scope starting...')

@pytest.fixture(scope='class')
def class_fixture():
    print('class scope starting...')

@pytest.fixture(scope='function')
def function_fixture():
    print('function scope starting...')

class TestClass:
    def test_method_01(self, session_fixture, package_fixture, module_fixture, class_fixture, function_fixture):
        print('test_method_01')

# session scope starting...
# package scope starting...
# module scope starting...
# class scope starting...
# function scope starting...
# test_method_01
```

如果你想将这个 `fixture` 抽离到单独的文件去管理，可以使用 `conftest.py`。这是一个约定的文件名。在这个文件中定义的 `fixture` 会被自动导入到所有测试文件中。无需手动 `import`。

在实际的项目中 `conftest.py` 通常会放在测试文件的根目录下。当然他不止一个，如果项目比较复杂，他可能存在于多个子目录下。

```
project/
├── conftest.py                    # 全局fixture：数据库、配置等
├── tests/
│   ├── conftest.py               # 测试根目录的共享fixture
│   ├── api/
│   │   ├── conftest.py           # API测试专用fixture
│   │   ├── test_users.py
│   │   └── test_products.py
│   ├── models/
│   │   ├── conftest.py           # 模型测试专用fixture
│   │   ├── test_user_model.py
│   │   └── test_product_model.py
│   └── utils/
│       ├── conftest.py           # 工具函数测试专用fixture
│       └── test_helpers.py
└── src/
```

### Fixture 的卸载与清理

在前面的示例中，一直在输出一个理念。`fixture return` 出来的内容会被测试用例所接收。实际上也可以把 `return` 替换成 `yield`。

这样在 `yield` 后面可以做一些清理的操作。

比如我们要连接一个数据库，那操作之后应该及时的去断开它

```py
@pytest.fixture(scope='function')
def connect_db():
    db.connect()
    # yield 之后的内容会在测试用例执行完毕之后执行
    yield
    db.close()

def test_db(connect_db):
    assert db.is_connected()
```

当然，如果在用例的执行过程中，出现了异常，那么 `yield` 之后的内容就不会被执行。
